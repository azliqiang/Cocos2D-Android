01. 动作类的基本概念    1.01  什么叫作动作类          01. 万物皆对象；          02. 创建对象之前，首先要有一个类；          03. Cocos2d 中，所有的动作都可以看做是一个对象；          04. 每一种动作，都会有一个相对应的类，这就是动作类。    1.02  动作类的相关知识          01. 动作类对象通常不会单独存在；              动作必须有一个东西执行它，比如“玩游戏”，那没什么意义，是谁在玩游戏呢？你、我、他、猫、狗；              动作类通常都是跟其它的对象一起来使用的；          02. 动作类对象需要作用在精灵、图层等对象上才能发挥作用；              精灵可以执行动作，而图层也可以执行动作；              在有些游戏开发当中，精灵是不动的，是图层在动，比如飞行射击的游戏，我们看到的是飞机在向前飞，实际上是游戏的背景在向后退；              甚至是 Camera 这样的效果，都需要在图层上做相应的变化；          03. 动作类包含有很多种类型，例如位移、缩放和旋转等；02. 动作类的分类方法    01. 首先，所有动作类都是 CCAction 的子类；    02. CCFllow 和 CCSpeed，严格意义上来讲，它们不是一种动作而是一种逻辑；    02. CCActionInstant，称为瞬时动作，一下子就执行完了；    03. CCActionInterval，延时动作，需要一段执行时间；    04. 下面我们把 CCFiniteTimeAction 目标集中在它身上。03. 基础瞬时动作使用方法          Cocos2d 中，动作的各类非常多，一定要总结其中的一些规律；    3.01  CCFlipX，CCFlipY，CCHide，CCShow          3.1.01  CCFlipX - X 轴镜像翻转                  将精灵从 X 轴上进行翻转          3.1.02  CCFlipY - Y 轴镜像翻转                  将精灵从 Y 轴上进行翻转          3.1.03  CCHide - 隐藏          3.1.04  CCShow - 显示    3.02  Source Code          3.2.01  Introduction                  这些基础的顺时动作，我们下面有代码来理解。          3.2.02  创建工程                  01. File --> New --> Android Application Project；                  02. --> Application Name: SG_02_Second，Package Name: org.openeducation.sg_02_second；                  03. --> Next --> Next --> Next --> Blank Activity (Create Activity)；                  04. --> Next --> Activity Name: MainActivity --> Finish          3.2.03  导入相关的包                  01. 包在 cocos2d-android 目录里，libs 里，把这里的所有东西拷到，我们工程的 libs 目录下；                  02. 然后，右键 cocos2d-android.jar --> Build Path --> Add to Build Path；                      把 cocos2d-android.jar 添加到构建路径中去；                      这时在 01_FirstGame 目录下，多出来一个 Referenced Libraries；                  03. 这些都是 Android 应用程序开发的基础知识。          3.2.04  拷代码                  01. Activity 的代码没有什么变化，都拷过来；                  02. 右键 org.openeducation.sg_02_second --> new --> class；                  03. Name：GameLayer --> Finish。          3.2.05  GameLayer.java                  3.2.5.01  Introduction                            01. 生成一个精灵对象，好测试那几个动画。                            02. 注意：flipX 指的是水平镜像旋转，是沿 Y 轴方向旋转；                            03. 所以如果是一张正脸的图是看不出来效果的，所以不用原来的图了。                  3.2.5.02  Source Code - FlipX                            public class GameLayer extends CCLayer {                            (1) CCSprite sprite;                                public GameLayer () {                            (2)     sprite = CCSprite.sprite("Sanji.png");                            (3)     this.addChild(sprite);                            (4)     sprite.setPosition(100, 100);		                                    // 1. 生成 动作对象                            (5)     CCFlipX flipX = CCFlipX.action(true);                                    // 2. 使用精灵对象执行动作对象                            (6)     sprite.runAction(flipX);                            }                  3.2.5.03  Source Code - FlipY                            练习。                  3.2.5.04  Source Code - Hide & Show                            默认情况下，精灵肯定是显示出来的，那我们就把这个精灵隐藏；                            public class GameLayer extends CCLayer {	                            CCSprite sprite;                            public GameLayer () {                                sprite = CCSprite.sprite("Franky.png");                                this.addChild(sprite);                                sprite.setPosition(100, 100);                                /*                                // 1. 生成 动作对象                                CCFlipX flipX = CCFlipX.action(true);                                // 2. 使用精灵对象执行动作对象                                sprite.runAction(flipX);                                */                                // 1. 生成动作对象                            (1) CCHide hide = CCHide.action();                                // 2. 执行动作对象                            (2) sprite.runAction(hide);                                }                            }                  3.2.5.05  Summary Up                            01. 从上面的动作使用上，我们可以总结出来如下的规律；                            02. 先生成一个动作对象，然后调用动作的 action() 方法，有或没有参数；                            03. 最后调用精灵对象的 runAction() 方法来运行它，就可以产生这样动作的结果。04. 基础延时动作使用方法    4.01  CCMoveTo，CCRotateTo，CCScaleTo，CCBlink          4.1.01  CCMoveTo - 移动至目标点          4.1.02  CCRotateTo - 旋转至指定的角度          4.1.03  CCSacleTo - 缩放至指定的倍数          4.1.04  CCBlink - 闪烁          延时动作就要比瞬时动作复杂一些，因为延时动作要持续一定的时间，最起码就多了动画执行时间这个属性。    4.02  Source Code - CCMoveTo          public GameLayer () {              sprite = CCSprite.sprite("Franky.png");              this.addChild(sprite);              sprite.setPosition(100, 100);		          (1) CGPoint point = CGPoint.ccp(400, 400);          (2) CCMoveTo moveTo = CCMoveTo.action(3, point);          (3) sprite.runAction(moveTo);              /*              // 1. 生成 动作对象              CCFlipX flipX = CCFlipX.action(true);              // 2. 使用精灵对象执行动作对象              sprite.runAction(flipX);              // 1. 生成动作对象              CCHide hide = CCHide.action();              // 2. 执行动作对象              sprite.runAction(hide);              */          }          如果想要相反的方向移动，就写成负的方向。    4.03  Source Code - CCRotateTo          public GameLayer () {              sprite = CCSprite.sprite("Franky.png");              this.addChild(sprite);              sprite.setPosition(100, 100);          (1) CCRotateTo rotateTo = CCRotateTo.action(3, 100);          (2) sprite.runAction(rotateTo);              /*              CGPoint point = CGPoint.ccp(400, 400);              CCMoveTo moveTo = CCMoveTo.action(3, point);              sprite.runAction(moveTo);		              // 1. 生成 动作对象              CCFlipX flipX = CCFlipX.action(true);              // 2. 使用精灵对象执行动作对象              sprite.runAction(flipX);              // 1. 生成动作对象              CCHide hide = CCHide.action();              // 2. 执行动作对象              sprite.runAction(hide);              */          }          01. 需要注意的是，Java 开发中用的是弧度，而 Cocos2d 中用的是角度，以后会讲弧度和角度的换算方法；          02. 如果 rotateTo 这个 action()里，第二个是正数就按顺时针旋转，如果是负数就按逆时针旋转。    4.04  Source Code - CCScaleTo          作业。    4.05  Source Code - CCBlink          作业。05. 总结