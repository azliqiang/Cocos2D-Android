00. Overview    01. CCSequence 是第一个动作执行完之后，再执行第二个动作；    02. CCSpawn 是一起执行所有的动作；    03. CCCallfuncN 是让我们在执行完一个动作后，执行一个回调函数；        它通常和 CCSequence 一起来使用；    04. CCFollow 它可以让一个精灵紧跟着另外一个精灵动。01. CCSequence 的使用方法    public class GameLayer extends CCLayer {	    (1) CCSprite sprite;        public GameLayer () {            sprite = CCSprite.sprite("Sanji.jpg");    (2)     CGPoint initPoint = CGPoint.ccp(100, 100);    (3)     this.addChild(sprite);    (4)     sprite.setPosition(initPoint);    (5)     CGPoint targetPoint = CGPoint.ccp(300, 300);    (6)     CCMoveTo moveTo = CCMoveTo.action(2, targetPoint);    (7)     CCRotateTo rotateTo = CCRotateTo.action(2, 180);    (10)    CCScaleTo scaleTo = CCScaleTo.action(2, 2);            // CCSequence 可以让多个动作先后执行    (8)     CCSequence seq = CCSequence.actions(moveTo, rotateTo, /*scaleTo*/);		    (9)     sprite.runAction(seq);        }    }       02. CCSpawn 的使用方法    public class GameLayer extends CCLayer {	        CCSprite sprite;        public GameLayer () {            sprite = CCSprite.sprite("Sanji.jpg");            CGPoint initPoint = CGPoint.ccp(100, 100);            this.addChild(sprite);            sprite.setPosition(initPoint);            CGPoint targetPoint = CGPoint.ccp(300, 300);            CCMoveTo moveTo = CCMoveTo.action(2, targetPoint);            CCRotateTo rotateTo = CCRotateTo.action(2, 180);            // CCSpawn 可以用来让多个动作同时执行    (1)     CCSpawn spawn = CCSpawn.actions(moveTo, rotateTo);    (2)     sprite.runAction(spawn);            /*            CCScaleTo scaleTo = CCScaleTo.action(2, 2);            CCSequence seq = CCSequence.actions(moveTo, rotateTo, /*scaleTo*/);            sprite.runAction(seq);            */        }    }03. CCCallfuncN 的使用方法    public class GameLayer extends CCLayer {	        CCSprite sprite;        public GameLayer () {            sprite = CCSprite.sprite("Sanji.jpg");            CGPoint initPoint = CGPoint.ccp(100, 100);            this.addChild(sprite);            sprite.setPosition(initPoint);            CGPoint targetPoint = CGPoint.ccp(300, 300);            CCMoveTo moveTo = CCMoveTo.action(2, targetPoint);            CCRotateTo rotateTo = CCRotateTo.action(2, 180);            CCCallFuncN func = CCCallFuncN.action(this, "onActionFinished");		            CCSequence seq = CCSequence.actions(moveTo, func);		            sprite.runAction(seq);            /*            // CCSpawn 可以用来让多个动作同时执行            CCSpawn spawn = CCSpawn.actions(moveTo, rotateTo);            sprite.runAction(spawn);            CCScaleTo scaleTo = CCScaleTo.action(2, 2);            CCSequence seq = CCSequence.actions(moveTo, rotateTo, /*scaleTo*/);            sprite.runAction(seq);            */        }        public void onActionFinished (Object sender) {		System.out.println("onActionFinished is Called.");		//CCScaleTo scaleTo = CCScaleTo.action(2, 3);		//player.runAction(scaleTo);	}    }    01. 执行这个方法有什么用呢？    02. 比如我们向屏幕外发射一颗子弹，当子弹运动结束后，要把这个子弹销毁，我怎么知道这个子弹运动结束呢？    03. 如果你想知道这个动画什么时候结束，你就把这个动画和 CCCallFuncN 这个动作放到 CCSequence 里，然后执行这个 CCSequence；    04. 这个 CCSequence，一执行的时候就会先执行第一个动作，然后就执行第二个动作，第二个动作就是我们的 CCCallFuncN，在这个 CCCallFuncN 里，就可以把要删除的对象删掉就可以了；    05. 实际上 Java 有动态特性的，详细的可以去查 Java 的反射机制。04. CCFollow 的使用方法    01. CCFollow 是一个精灵怎么动另一外精灵也怎么动，而我们这里一般不会是这样，而是一个 Layer 跟着一个精灵后面；    02. 由于我们没有介绍 Layer，所以我们就先不代码了。05. 总结