/* * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ * * Copyleft (C) 2009-2014 * COEO - China Open Education Organization * "+++New Life+++" Team for Computer Science * Free as in freedom. The Truth Will Free You. * 张开自由的翅膀，真理要释放你。 * To teach the inexperienced the ropes  * and give our young people a grasp on reality. * 教导没有经验的得以丰富，给予青年人开启真理的钥匙。 * The old life is gone; a new life burgeons! * 告别飘逝的过去，拥抱怒放的新生！ * * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ * * This file is available to you under a choice of one of two licenses. * * GPL * * This program is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 as published * by the Free Software Foundation. * * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE * ARE EXPRESSLY DISCLAIMED. * * See the GNU General Public License * for more details. * * http://www.opensource.org/licenses/gpl-license.html * http://www.gnu.org/copyleft/gpl.html * * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *  * BSD * *  Alternatively you can redistribute this file under the terms of the *  BSD license as stated below: * *  Redistribution and use in source and binary forms, with or without *  modification, are permitted provided that the following conditions *  are met: *  1. Redistributions of source code must retain the above copyright *     notice, this list of conditions and the following disclaimer. *  2. Redistributions in binary form must reproduce the above copyright *     notice, this list of conditions and the following disclaimer in *     the documentation and/or other materials provided with the *     distribution. *  3. The names of its contributors may not be used to endorse or promote *     products derived from this software without specific prior written *     permission. * *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ * * Description: *     This file describe Cocos2d-Android Aircraft game. * * Original Date: *     Jul-28-2014 * * Modified Date: *     Jul-29-2014 * * Authors: *     Yuhui    <abrahambenyu@gmail.com> * * Current Version: *     0.0.5 * * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Table of Centents    01. Cocos2d Introduction    02. Cocos2d Installation    03. Principle Genesis, First Game    04. Soruce Code FRist Game    05. Sprite First Experience01. Cocos2d Introduction    1.01  Overview          1.1.01  Introduction                  01. Cocos2d 大名鼎鼎，使用范围最广，为什么程序员们选择。                  02. 引擎是发动机的意思，Engine，发动机为洗车提供了前进的动力；                  03. 游戏引擎和洗车引擎有相似之处；                  04. 渲染引擎，图象 2d 和 3d 如何在手机上显示出来；                  05. 物理引擎，对现实世界的模拟，比如一个小球从空中掉下来，它受到了重力和摩擦力的影响，                      如何来判断小球的轨迹；                  06. 碰撞监测系统，玩雷电，子弹如何撞上敌机；                  07. 我们是在游戏引擎的基础上去开发，如果没有游戏引擎也可以，但是这样做效率低，                      开发周期会变长，不要重复造轮子。          1.1.02  Cocos2d Come From                  01. Cocos2d-x 是最火的一个，用 C++ 写的；                  02. Cocos2d-android-1 基于 Java 写的；                  03. 如果你掌握了一个，转到其它上只是语言上的区别而已；                  04. Cocos2d-android 也是一个项目，更新太慢，后来一些人出来了一起开了这个项目                      Cocos2d-android-1。     1.02  Cocos 2D Related Resource           01. Cocos2d.org；           02. Cocos2d-x.org；           03. https://github.com/ZhouWeikuan/cocos2d。    1.03  Why Use Cocos2d Engine          01. 提升开发效率；          02. 降低学习成本；          03. 享受社区支持，十分活跃。    1.04  Cocos2d Engine Advantage    1.05  Cocos2d Application Structure          1.5.01  Introduction                  01. 导演，每个游戏都是有导演的，导演的责任，他控制着整个游戏的流程，                      掌握着游戏当中的所有资源，一个游戏当中只能有一个导演；                  02. 场景，导演来管理场景，场景简单的说是关卡；第一关过后一个，黑屏，进                      入下一个关卡；                  03. 布景层，或称为图层，用过 PhotoShop 的更知道，一个场景中有很多图层，                      比如超级玛丽里，蓝天和白云是一层，砖块和玛丽奥是一层，敌人是一层，                      得分数据是一层，多个布景层组成一个场景；                  04. 布景层又包括精灵，画面上一切会动的都是精灵，玛丽奥本身是精灵，                      敌人是精灵，蘑菇、炮弹、乌龟、吃人的花，砖块也是精灵，白云会动也是精灵。          1.5.02  Cocos2d Core Class    1.06  Conclusion02. Cocos2d Installation    2.01  Cocos2d Source Download          01. 两个地方托管，原来是在谷歌，后来转到最大的程序员社交网站：https://github.com；          02. 可以注册帐号的，然后登陆，搜索：cocos2d-android，ZhouWeikuan 这个就是；          03. 用 git 可以下载，或是 Download ZIP 以 FPT 的协议下载。    2.02  Cocos2d Project Directory Structure          2.2.01  Decompression                  01. 解压 cocos2d-master-xxx.zip；                  02. 三个项目：Cocos2d-android，Cocos2d-iphone，JBox2D_2.0.1。          2.2.02  Import Project Using Eclipse                  01. File --> Import --> Android --> Existing Android Code Into Workspace --> Next -->                  02. Root Directory: Browse... (...\cocos2d-android-1\cocos2d-master\cocos2d-android) -->                  03. Copy projects into workspace --> Finish          2.2.03  Directory Structure                  01. 这是一个标准的 Androi 项目；                  02. src 文件夹里放的都是源代码；                  03. gen 文件夹里放的是生成文件；                  04. assets 里放的是一些需要使用的图片，还有一些资源文件都在这里放着；                  05. libs 里放的是 jar 文件，libgdx.so 是 C 和 C++ 平台的库，分为 ARM 和 X86 版本，                      我们真正用的是 cocos2d-android.jar 这个库文件；                  06. res 里放的同样是资源文件。          3.2.04  Source Code Description                  01. org.cocos2d.noes 里，org.cocos2d.tests 里是非常好的测试文件很多个；                  02. 比如 MenuTest.java 是测试菜单的，ActionTest.java 所谓的动作，                      比如物体的平移、旋转、缩放、透明度变化等等都归作为 Action；场景测试、卷轴的测试等等，                      这些例子是我们学习 Cocos2d 最好的资源；一会儿我们就要把它运行起来；                  03. 打开 AndroidManifest.xml 看我们默认的 Activity：                      <activity android:name=".Cocos2D"                                android:label="@string/app_name">                          <intent-filter>                              <action android:name="android.intent.action.MAIN"/>                              <category android:name="android.intent.category.LAUNCHER"/>                          </intent-filter>                      </activity>                      看不看都可以，无所谓。    2.03  Import Source Code          2.3.01  Running Emulator                  01. Window --> Android Virtual Device Manager --> 选择一个模拟器 --> Start --> Launch，                      如果没有就新建一个；                  02. 一定要有一台真正的手机进行测试，不然的话，虚拟机就太慢了！                  03. 模拟器上也不是所有的都能测试；性能太差！          2.3.02  Cancel Is Library                  01. 右键 cocos2d_android --> Run As --> 1 Android Application -->                       报错 "Android library projects cannot be launched."                      （这个项目现在是 一个包项目要改成一个 Anroid 项目）                  02. 右键 cocos2d_android --> Properties --> Android -->                       把 Is Library 上的“对号”去掉！                      （已经变成了一个普通的 Android 程序） -->                  03. Apply --> OK          2.3.03  Multiple dex files define Lorg/cocos2d/Cocos2D$1                  01. 右键 cocos2d_android --> Run As --> 1 Android Application -->                  02. 报错 "Your project contians error(s), please fix them before running your application."                   03. （错误：cocos2d_android] Conversion to Dalvik format failed: Unable to execute dex:                       Multiple dex files define Lorg/cocos2d/Cocos2D$1;）                  04. --> 原因是 Cocos2d 的源代码在 src 目录里，同样的 libs 里有 cocos2d-android.jar 也是，                      jar 里的内容是源代码中文件编程生成的，那就两份了！重复了                  05. --> 那它把这个 cocos2d-android.jar 删掉！    2.04  Running Cocos2d Example          2.4.01  Action Test                  01. 这是我们做 Android 开发看到的简单的 ListView，这个 Test 就是 org.cocos2d.test 里的类；                  02. --> 我们看一下这个 Action Test --> CTRL+F11 （切换到横屏）；                  03. 点击右键 Move to / Move By，（移动精灵要靠 Move to / Move By 来完成）；                  04. RotateTo / RotateBy（旋转动画）；                  05. ScaleTo / ScaleBy（缩放动画）；                  06. JumpTo / JumpBy（跳跃动画）；                  07. BezierBy / BezierTo（贝塞尔曲线动画）；                  08. Blink（闪烁动画）；                  09. FadeIn / FadeOut（淡入淡出动画）；                  10. TintTo / TintBy（颜色变化动画）；                  11. Animation（连续的动画，真正的动画）；                  12. Sequence: Move + Rotate（序列：先动 再加 旋转）；                  13. Spawn: Jump + Rotate（一边跳一边旋转），等等各种各样的动画。          2.4.02  Box2dTest                  01. 点击屏幕就会产生盒子坠落的动画；                  02. 这些盒子能够碰撞、坠落、翻滚，如果让我们自己去代码实现的话，那还是要费力气的！                  03. 有了游戏引擎之后，来实现这些还是要轻松很多的！    2.05  Conclusion          01. 这些例子就不一一全演示了，这些例子是学习非常好的范本；          02. 可惜的是，Cocos2d-android 没有完善的文档，有时还需要去查看源代码去看究竟这个代码干了什么事！          03. 所以导入源代码的意义就非常的重要了！03. Principle - Genesis, First Game    3.01  My First Cocos2d Program          3.1.01  Application                  创建一个 Android 应用程序；          3.1.02  SurfaceView                  生成一个 SurfaceView 对象，作为 Activity 当中所显示的内容；          3.1.03  CCDirector                  01. 得到 CCDirector 对象，并通过该对象设置应用程序的各种属性；                  02. 注意，是得到，不是生成，因为 CCDirector 使用单态模式控制的对象；                  03. 一个应用程序里有且只有一个 CCDirector，它控制着整个应用程序所有的资源。    3.02  Set Application-Related Properties          3.2.01  attachInView                  01. director.attachInView(mGLSurfaceView);                  02. 用于设置应用程序所使用的 GL 视图对象；                  03. 一个 Cocos2d 这样一个游戏，必然涉及到图形的渲染，图形的渲染必然要在一个 View 上完成；                  04. 上面一行代码就是去要设置整个图形渲染的过程要在哪一个 View 上完成的。          3.2.02  setDeviceOrientation                  01. director.setDeviceOrientation(CCDirector.kCCDeviceOrientationLandscapeLeft);                  02. 用于设置应用程序的方向；                  03. 这个游戏是横板的还是竖板的。          3.2.03  setDisplayFPS                  01. director.setDisplayFPS(true);                  02. 设置应用程序是否需要显示应用程序的 FPS 值；                  03. FPS 是 Frame Per Seconds，就是屏幕左下角显示的一个及时的帧数。          3.2.04  setAnimationInterval                  01. director.setAnimationInterval(1.0f / 30);                  02. 设置每帧所需要的时间；                  03. 设置所有应用程序的帧数。    3.03  Generate Backgroud and Scenes          01. 创建一个布景层类，继承 CCLayer;          02. 调用 CCScene 类的 node() 方法生成场景对象；          03. 生成布景层对象，并添加至场景对象当中；          04. 执行场景对象。    3.04  Running Cocos2d Program          Run As --> Android Application04. Source Code of First Game    4.01  Introduction          01. 看到这大家可能觉得枯燥，全部都是概念啊，记不住，晕菜了！          02. 不用着急，我们就来代码演示一下！    4.02  New Project          01. File --> New --> Android Application Project；          02. --> Application Name: SG01_First，Package Name: org.openeducation.sg_01_first；          03. --> Next --> Next --> Next --> Blank Activity (Create Activity)；          04. --> Next --> Activity Name: MainActivity --> Finish    4.02  Including Cocos2d Libraries          01. 包在 cocos2d-android 目录里，libs 里，把这里的所有东西拷到，我们工程的 libs 目录下；          02. 然后，右键 cocos2d-android.jar --> Build Path --> Add to Build Path；              把 cocos2d-android.jar 添加到构建路径中去；              这时在 SG_01_First 目录下，多出来一个 Referenced Libraries；          03. 这些都是 Android 应用程序开发的基础知识。    4.03  Coding Program          4.3.01  Generate a CCGLSurfceView                  4.3.1.01  Source Code                            public class MainActivity extends Activity {                                // Cocos2d 引擎将会把图形绘制在该 view 对象上                            (1) private CCGLSurfaceView view = null;	                                @Override                                protected void onCreate(Bundle savedInstanceState) {                                    super.onCreate(savedInstanceState);                            (2)     view = new CCGLSurfaceView(this);                            (3)     setContentView(view);                                    setContentView(R.layout.activity_main);                                }                  4.3.1.02  Analysis                            01. 让我们来分析一下 CCGLSurfaceview 这个名字；                            02. CC 明显是来自于 Cocos2d 的，看导入的包为：import org.cocos2d.opengl.CCGLSurfaceView;                            03. GL 说明是使用 OpenGL 技术的；                            04. SurfaceView 又指明它是一个 SurfaceView；                            05. 其实 CCGLSurfaceView 它是一个 SurfaceView 的一个子类。                  4.3.1.03  Description                            01. view = new CCGLSurfaceView(this);                             02. 生成这个 view 对象的目的，就是 Cocos2d 渲染图形的时候，要把这个图形画在这个 view 对象上去。          4.3.02  Get CCDirector Object                  4.3.2.01  Source Code                            @Override                            protected void onCreate(Bundle savedInstanceState) {                                super.onCreate(savedInstanceState);                                view = new CCGLSurfaceView(this);                                setContentView(view);                                // 得到 CCDirector 对象                            (1) CCDirector director = CCDirector.sharedDirector();                                //setContentView(R.layout.activity_main);                            }                  4.3.2.02  Analysis                            01. 让我们来分析一下 CCDirector.sharedDirector 这个名字；                            02. 明显这个 sharedDirector() 是一个静态方法；                            03. shared 是共享的，也就是说我们得到一个共享的Director 对象；                            04. 为什么是共享的呢？一个 Cocos2d 应用程序当中只能有一个 Director 对象；                            05. 只要有用到 CCDirector 的地方，那就这样使用。          4.3.03  Set Application-Related Properties                  4.3.3.01  Source Code                            @Override                            protected void onCreate(Bundle savedInstanceState) {                                super.onCreate(savedInstanceState);                                view = new CCGLSurfaceView(this);                                setContentView(view);                                // 得到 CCDirector 对象                                CCDirector director = CCDirector.sharedDirector();                                /* 设置应用程序相关的属性 */                                // 设置当前游戏程序当中所使用的 view 对象                            (1) director.attachInView(view);                                // 设置游戏是否显示 FPS 值                            (2) director.setDisplayFPS(true);                                // 设置游戏渲染一帧数据所需要的时间                            (3) director.setAnimationInterval(1 / 30.0);                                //setContentView(R.layout.activity_main);                            }                  4.3.3.02  Analysis                            4.3.3.2.01  director.attachInView                                        01. 上边生成的 view 对象并没有和 Cocos2d 引擎建立起关系；                                        02. director.attachInView(view);这样一个方法就是把这个 view 对象和我们 Cocos2d 引擎建立关系；                                        03. 告诉导演，你要画图向什么地方画。                            4.3.3.2.02  director.setDisplayFPS                                        01. FPS 就是每秒钟刷新的帧数，玩过游戏的人都应该知道 FPS 理论值要保持 30 帧以上这个游戏才能是流畅的；                                        02. 设置 FPS 值 setDisplayFPS 值，咱们就可以看到我们这个应用程序运行起来够流畅。                            4.3.3.2.03  director.setAnimationInterval                                        01. 每帧所需要的时间；                                        02. 1 / 30.0，那一秒钟就是要渲染 30 次；                  4.3.3.03  Accomplish                            设置应用程序的属性就算是完成了。          4.3.04  Generating Scenes Object Layers                  4.3.4.01  Introduction                            现在 director 对象已经有了，而且已经有了属性，那么根据 PPT 我们就该生成场景对象了；                  4.3.4.02  Source Code                            @Override                            protected void onCreate(Bundle savedInstanceState) {                                super.onCreate(savedInstanceState);                                view = new CCGLSurfaceView(this);                                setContentView(view);                                // 得到 CCDirector 对象                                CCDirector director = CCDirector.sharedDirector();                                // 设置应用程序相关的属性                                // 设置当前游戏程序当中所使用的 view 对象                                director.attachInView(view);                                // 设置游戏是否显示 FPS 值                                director.setDisplayFPS(true);                                // 设置游戏渲染一帧数据所需要的时间                                director.setAnimationInterval(1 / 30.0);                                // 生成一个游戏场景对象                            (1) CCScene scene = CCScene.node();                                //setContentView(R.layout.activity_main);                            }                  4.3.4.03  Analysis                            01. node 是 Cocos2d 最基本的一个类；                            02. 以后我们再说。          4.3.05  Generating an Background Object Layer                  4.3.5.01  Introduction                            01. 下一步要生成一个图层对象；                            02. 并且要把这个图层对象加入到场景对象里面去；                            03. 要生成一个图层对象，我们就要新建一个类；                  4.3.5.02  New Class                            01. 右键 org.openeducation.sg_01_first --> new --> class；                            02. Name：GameLayer --> Finish。                  4.3.5.03  Source Code - GameLayer.java                            图层对象就不那么简单了。                            package com.openeducation.sg_01_first;                            import org.cocos2d.layers.CCLayer;                                 // 注意，这里的 GameLayer 类一定要继承 CCLayer                            (1)  public class GameLayer extends CCLayer {                            (2)      public GameLayer() {                                     }                                 }                  4.3.5.04  Description                            01. 这样图层或布景层这样一个类就生成了；                            02. 接下来要把这个布景层类的对象添加到场景当中去。          4.3.06  Add Background Object to Scene                  @Override                  protected void onCreate(Bundle savedInstanceState) {                      super.onCreate(savedInstanceState);                      view = new CCGLSurfaceView(this);                      setContentView(view);                      // 得到 CCDirector 对象                      CCDirector director = CCDirector.sharedDirector();                      /* 设置应用程序相关的属性 */                      // 设置当前游戏程序当中所使用的 view 对象                      director.attachInView(view);                      // 设置游戏是否显示 FPS 值                      director.setDisplayFPS(true);                      // 设置游戏渲染一帧数据所需要的时间                      director.setAnimationInterval(1 / 30.0);                      // 生成一个游戏场景对象                      CCScene scene = CCScene.node();                      // 生成布景层对象		  (1) GameLayer gameLayer = new GameLayer();                      // 将布景层对象添加至游戏场景当中                  (2) scene.addChild(gameLayer);                      //setContentView(R.layout.activity_main);                  }          4.3.06  Run this Scene Objects                  @Override                  protected void onCreate(Bundle savedInstanceState) {                      super.onCreate(savedInstanceState);                      //setContentView(R.layout.activity_main);                      view = new CCGLSurfaceView(this);                      setContentView(view);                      // 得到 CCDirector 对象                      CCDirector director = CCDirector.sharedDirector();                      // 设置应用程序相关的属性                      // 设置当前游戏程序当中所使用的 view 对象                      director.attachInView(view);                      // 设置游戏是否显示 FPS 值                      director.setDisplayFPS(true);                      // 设置游戏渲染一帧数据所需要的时间                      director.setAnimationInterval(1 / 30.0);                      // 生成一个游戏场景对象                      CCScene scene = CCScene.node();                      // 生成布景层对象		      GameLayer gameLayer = new GameLayer();                      // 将布景层对象添加至游戏场景当中                      scene.addChild(gameLayer);                      // 运行游戏场景                  (1) director.runWithScene(scene);                  }    4.04  Running and Debugging          01. 漆黑一片，左下角有一个跳动的数字，就是因为设置了 FPS 值；          02. 这个 FPS 值在 30 附近来回的跳动；          03. 为什么在 30 来回跳动？因为：director.setAnimationInterval(1 / 30.0);                   04. 虽然现在什么都没有，以后我们就会往这上面绘制图形。    4.05  Conclusion          01. 在模拟器上运行的时候 FPS 值不会达到 30，速度不够，但在手机上运行没问题；          02. Eclipse 有时候不是那么快，需要等待一会儿才会检查完毕；          03. 写完代码要保存，经常写代码就会保存加“Ctrl + Shift + o”来先解决错误。05. Sprite First Experience    5.01  What is Sprite          01. 精灵是游戏当中的一个元素，通用用于代表画面当中的一个事件，例如主人公、NPC 和背景元素等；          02. 一个精灵对象通常都与一张图片关联；              精灵对象本身是不包含任何内容的，要把一个图片关联到精灵对象上，那这个图片就会显示在精灵相关的位置上；          03. 精灵对象通常可以通过运行动作对象 (CCAction) 来产生动画效果。    5.02  How to Generate a Sprite          5.2.01  Introduction                  01. 在昨天的例子的基础上进行；                  02. 昨天的代码已经把图层、布景层、场景对象都生成好了，也运行了；                  03. 下面我们就在这个布景层类的构造函数中，添加对象；                  04. 精灵对象要跟一张图片相关联，那我们找一张图片，把它入到 assets 目录下；                  05. 把这个图片改个名字叫 player.png。          5.2.02  Source Code                  public class GameLayer extends CCLayer {                      // 声明一个精灵对象                  (1) CCSprite player;                      public GameLayer() {                          // 初始化精灵对象                  (2)     player = CCSprite.sprite("player.png");                          // 设置精灵对象的位置                  (3)     player.setPosition(100, 100);                      }                  }          5.2.03  Description                  01. 先声明一个精灵对象；                  02. 然后初始化精灵对象，默认就是从 assets 目录中去寻找这个图片；                            03. assets 是放置各种资源的文件夹，其中就包括图片；                  04. assets 文件怎么使用是 Android 的知识；                      它需要得到 assetsManager，assets 管理器才能得到里面的资源；                  05. 我们这里使用就可以了，默认就会到 assets 目录下去找；                  06. 设置完坐标，我们先运行一下模拟器，我们这里有些事情需要说一下；                  07. 我们需要考虑精灵坐标的原点在哪里？                      Android 的坐标系原点在屏幕的左上角，向右为 X 轴的正方向，向下为 Y 轴正方向；                      而 Cocos2d 引擎的坐标系原点在屏幕的左下角,向右为 X 轴的正方向，向上为 Y 轴正方向。    5.03  Add Sprite Object to Backgroud Layer          5.3.01  Source Code                  public class GameLayer extends CCLayer {                      // 声明一个精灵对象                      CCSprite player;                      public GameLayer() {                          // 初始化精灵对象                          player = CCSprite.sprite("player.png");                          // CGPoint 对象通常用于表示坐标，或者是表示向量                  (1)     CGPoint point = CGPoint.ccp(100, 100);                          // 设置精灵对象的位置                  (2)     player.setPosition(point);                          // 将精灵对象添加至布景层当中                          this.addChild(player);                      }                  }          5.3.02  Description                            01. 将精灵对象添加至布景层当中后，运行一下看看我们的效果；                  02. 我们在 Cocos2d 中经常会用 CGPoint 来设置位置，那我们改一下代码，一样的效果。    5.04  Running Actrion Object (CCAction)          5.4.01  Introduction                  01. 你把这个精灵对象加到布景层中，默认这个精灵是不会动的；                  02. 然后，让这个精灵运行一个动作对象；                  03. 动作对象，它是 CCAction 这个类的子类所生成的对象；                  04. 这样的对象都可以去运行各种各样的运作；                  05. 它代表着各种各样的动作，比如跳跃、运动、旋转。          5.4.02  Source Code                  public class GameLayer extends CCLayer {                      // 声明一个精灵对象                      CCSprite player;                      public GameLayer() {                          // 初始化精灵对象                          player = CCSprite.sprite("player.png");                          //player.setPosition(100, 100);                          // CGPoint 对象通常用于表示坐标，或者是表示向量                          CGPoint point = CGPoint.ccp(100, 100);                          // 设置精灵对象的位置                          player.setPosition(point);                          // 将精灵对象添加至布景层当中                          this.addChild(player);                  (2)     CGPoint target = CGPoint.ccp(400, 100);                          // 生成一 CCPoint 对象，该对象个表示一个跳跃动作                  (1)     CCJumpTo jumpTo = CCJumpTo.action(3, target, 200, 1 /*3*/);                          // 使用精灵对象执行该动作                  (3)     player.runAction(jumpTo);                      }                  }          5.4.03  Description                  01. 我们先来看看它最基本的用法，CCJumpTo；                  02. CCJumpTo 代表的一种动作，一种跳跃的动作；                      跳到什么地方去这个动作；                      CCJumpTo 是 CCAction 的子类；                      time，是这一次跳跃需要花多少时间？                  03. 好，我们写好了 player.runAction(jumpTo); 那么我们运行一下。                  04. 我们改变一下，跳跃次数，和高度来玩一下！    5.05  Running and Debugging          5.1.01  Logcat          5.1.02  Refactoring    5.06  Conclusion